name: Deploy Next.js to Remote Server
on:
  push:
    branches: 
      - "pre-prod"   # Preproduction
      # - "staging"         # Staging

    # pull_request:
    #   types: 
    #     - closed
    #   branches: 
    #     - "main"      # Production

jobs:
  preprod-deploy:
    name: Deploy changes to preprod server
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/pre-prod' }}

    steps:
      # 1. Checkout repository
      - name: Check out repository
        uses: actions/checkout@v4

      # 2. Set up Node.js (for lint + type-check + tests)
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24

      # 3. Log in to GitHub Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT != '' && secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}

      # 4. Build and push Docker image
      - name: Build and push Docker image
        run: |
          IMAGE_NAME=$(echo "ghcr.io/${{ github.repository }}/frontend" | tr '[:upper:]' '[:lower:]')
          IMAGE_ENV=pre-prod
          IMAGE_TAG=$IMAGE_ENV-${{ github.sha }}
          LATEST_TAG=$IMAGE_ENV-latest

          echo "Building image $IMAGE_NAME:$IMAGE_TAG"
          docker build -t $IMAGE_NAME:$IMAGE_TAG -f docker/$IMAGE_ENV/Dockerfile .
          docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:$LATEST_TAG
          docker push $IMAGE_NAME:$IMAGE_TAG
          docker push $IMAGE_NAME:$LATEST_TAG

          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "IMAGE_TAG=$LATEST_TAG" >> $GITHUB_ENV
          echo "IMAGE_ENV=$IMAGE_ENV" >> $GITHUB_ENV

      # 5. Deploy on VPS
      - name: Deploy via SSH and Docker Compose
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.AWS_STAGING_1_HOST }}
          username: ${{ secrets.AWS_STAGING_1_USER }}
          password: ${{ secrets.AWS_STAGING_1_PASS }}
          port: ${{ secrets.AWS_STAGING_1_PORT }}
          script: |
            set -e
            APP_DIR="/opt/products/docketmaster/$IMAGE_ENV/frontend"
            IMAGE_NAME=${{ env.IMAGE_NAME }}
            IMAGE_TAG=${{ env.IMAGE_TAG }}
            IMAGE_ENV=${{ env.IMAGE_ENV }}

            mkdir -p $APP_DIR
            cd $APP_DIR

            # Create/update compose.yml if needed
            if [ -f compose.yml ]; then
            echo "Updating compose file..."
            else
            echo "Creating compose file..."
            fi
            cat > compose.yml <<EOF
            name: docketmaster-$IMAGE_ENV
            services:
              web:
                container_name: docketmaster-$IMAGE_ENV-frontend
                image: $IMAGE_NAME:$IMAGE_TAG
                ports:
                  - "127.0.0.1:9801:9800"
                restart: unless-stopped
                environment:
                  - NODE_ENV=production
                env_file:
                  - .env
                scale: 1
                # volumes:
                  # - ./.env:/app/.env:ro # Mount the external .env file
            EOF
            echo "Compose file is updated!"

            echo "Logging into GHCR..."
            # Pull new image and start container
            echo ${{ secrets.GHCR_PAT }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker compose pull
            docker compose -f compose.yml up -d

